# -*- coding: utf-8 -*-
"""S1_S2_DATA_SORT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F7x78Edm-f2ESB5CtYArtJqo2XxuaH9X

**S1_S2_DATA_SORT.**
"""

# ===============================================
# 📌 Merge Sentinel-1 and Sentinel-2 by ±5 Days
# 🔁 Use Sentinel-1 as base, match closest Sentinel-2
# 📤 Export as Excel, ready for download
# ===============================================

# Install dependencies (if using Google Colab)
!pip install xlsxwriter --quiet

# === Step 1: Import Libraries ===
import pandas as pd
from google.colab import files  # For download (only in Colab)

# === Step 2: Load Data ===
excel_file = 'Jodhpur_data.xlsx'  # 📂 Path to your Excel file
df_s1 = pd.read_excel(excel_file, sheet_name='sentinel-1')
df_s2 = pd.read_excel(excel_file, sheet_name='sentinel-2')

# Convert date columns to datetime for accurate filtering
df_s1['DATE'] = pd.to_datetime(df_s1['DATE'])
df_s2['DATE'] = pd.to_datetime(df_s2['DATE'])

# === Step 3: Combine Records Based on Closest Match in ±5 Days ===
combined_rows = []

for idx, row_s1 in df_s1.iterrows():
    date_s1 = row_s1['DATE']

    # 🎯 Filter Sentinel-2 dates within ±5 days of current Sentinel-1 date
    s2_candidates = df_s2[
        (df_s2['DATE'] >= date_s1 - pd.Timedelta(days=5)) &
        (df_s2['DATE'] <= date_s1 + pd.Timedelta(days=5))
    ].reset_index(drop=True)

    # ✅ If matching dates exist, pick the closest one
    if not s2_candidates.empty:
        closest_row = s2_candidates.iloc[(s2_candidates['DATE'] - date_s1).abs().argsort()[0]]

        combined_row = {
            'DATE': date_s1,
            'VV': row_s1['VV'],
            'VH': row_s1['VH'],
            'VH/VV': row_s1['VH/VV'],
            'VH-VV': row_s1['VH-VV'],
            '(VH-VV)/(VH+VV)': row_s1['(VH-VV)/(VH+VV)'],
            'RVI': row_s1['RVI'],
            'LSWI1': closest_row['LSWI1'],
            'LSWI2': closest_row['LSWI2']
        }
    else:
        # ❌ No match: include only Sentinel-1 data, leave LSWI fields empty
        combined_row = {
            'DATE': date_s1,
            'VV': row_s1['VV'],
            'VH': row_s1['VH'],
            'VH/VV': row_s1['VH/VV'],
            'VH-VV': row_s1['VH-VV'],
            '(VH-VV)/(VH+VV)': row_s1['(VH-VV)/(VH+VV)'],
            'RVI': row_s1['RVI'],
            'LSWI1': None,
            'LSWI2': None
        }

    combined_rows.append(combined_row)

# === Step 4: Create DataFrame & Save Excel ===
if combined_rows:
    df_combined = pd.DataFrame(combined_rows)
    df_combined.sort_values(by='DATE', inplace=True)
    df_combined.reset_index(drop=True, inplace=True)

    output_path = 'Jodhpur_sorted_combined_s1base.xlsx'
    with pd.ExcelWriter(output_path, engine='xlsxwriter') as writer:
        df_combined.to_excel(writer, sheet_name='Combined_Sorted_S1Base', index=False)

    print(f"✅ Combined sorted Excel file saved: {output_path}")

    # === Step 5: Trigger File Download (for Colab) ===
    files.download(output_path)
else:
    print("⚠️ No data to combine.")